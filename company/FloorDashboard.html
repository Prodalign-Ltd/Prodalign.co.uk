<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Station Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
:root{
  --bg:#071826;
  --panel:rgba(255,255,255,0.06);
  --border:rgba(255,255,255,0.10);
  --text:#ffffff;
  --muted:rgba(255,255,255,0.78);

  --green:#2e7d32;
  --green2:rgba(46,125,50,0.18);

  --amber:#f9a825;
  --amber2:rgba(249,168,37,0.18);

  --gray:#90a4ae;
  --gray2:rgba(144,164,174,0.14);

  --radius:14px;
  --danger:#d32f2f;
}

*{box-sizing:border-box}

body{
  margin:0;
  font-family:system-ui;
  background:
    radial-gradient(1200px 700px at 20% -10%, rgba(245,124,0,0.18), transparent 60%),
    radial-gradient(900px 600px at 120% 0%, rgba(211,47,47,0.12), transparent 55%),
    linear-gradient(180deg,#071826,#06131e);
  color:var(--text);
}

/* HEADER */
header{
  border-bottom:1px solid var(--border);
  background:#0b2235;
  padding:14px 14px 16px;

  display:grid;
  grid-template-columns: 1fr auto 1fr;
  align-items:start;
  gap:10px;
}

.header-center{
  display:flex;
  flex-direction:column;
  align-items:center;
  text-align:center;
  gap:10px;
  padding-top:4px;
}

.stationTitle{
  font-weight:950;
  font-size:1.8rem;
  margin:0;
}

/* Logout button (top-right) */
.logoutWrap{
  display:flex;
  justify-content:flex-end;
}

.logoutBtn{
  border:1px solid rgba(211,47,47,0.40);
  border-radius:12px;
  padding:10px 12px;
  background:rgba(255,255,255,0.08);
  color:#fff;
  cursor:pointer;
  font-weight:900;
  transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
}
.logoutBtn:hover{
  background: rgba(255,255,255,0.12);
  border-color: rgba(211,47,47,0.55);
  transform: translateY(-1px);
}

/* LEGEND */
.legend{
  display:flex;
  justify-content:center;
  flex-wrap:wrap;
  gap:10px;
  color:var(--muted);
  font-weight:850;
}

.legendItem{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(0,0,0,0.18);
}

.swatch{
  width:10px;height:10px;border-radius:999px;
}
.wip{background:var(--green)}
.available{background:var(--amber)}
.na{background:var(--gray)}

/* PAGE */
.page{
  padding:18px;
  max-width:1300px;
  margin:auto;
  display:grid;
  gap:18px;
}

/* SECTIONS */
.section{
  border-radius:var(--radius);
  border:1px solid var(--border);
  background:var(--panel);
  overflow:hidden;
}

.sectionHead{
  padding:14px;
  font-weight:900;
  text-align:center;
  border-bottom:1px solid rgba(255,255,255,0.08);
}

.sectionBody{
  min-height:180px;
  display:grid;
  place-items:center;
  color:var(--muted);
  font-weight:800;
}

.wipSection .sectionHead{background:var(--green2)}
.availableSection .sectionHead{background:var(--amber2)}
.naSection .sectionHead{background:var(--gray2)}

  /* JOB CARDS */
.sectionBody{
  padding: 14px;
  display: block;          /* override the old centered placeholder layout */
  min-height: 180px;
}

.jobsGrid{
  display: grid;
  gap: 12px;
}

.jobCard{
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.16);
  border-radius: 14px;
  padding: 12px;
}

.jobTop{
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:flex-start;
}

.jobTitle{
  font-weight: 950;
  letter-spacing: 0.2px;
}

.jobMeta{
  color: rgba(255,255,255,0.75);
  font-weight: 850;
  margin-top: 6px;
  line-height: 1.35;
  font-size: 0.92rem;
}

.jobOps{
  margin-top: 10px;
  color: rgba(255,255,255,0.70);
  font-weight: 850;
  font-size: 0.9rem;
  line-height: 1.35;
}

.jobBtns{
  margin-top: 12px;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}

.smallBtn{
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 12px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.08);
  color: #fff;
  cursor: pointer;
  font-weight: 900;
}

.smallBtn:hover{
  background: rgba(255,255,255,0.12);
  transform: translateY(-1px);
}

.smallBtn.primary{
  border-color: rgba(46,125,50,0.45);
  background: linear-gradient(180deg, rgba(46,125,50,0.22), rgba(255,255,255,0.08));
}

.smallBtn.warn{
  border-color: rgba(249,168,37,0.55);
  background: linear-gradient(180deg, rgba(249,168,37,0.18), rgba(255,255,255,0.08));
}

.smallBtn.danger{
  border-color: rgba(211,47,47,0.45);
  background: linear-gradient(180deg, rgba(211,47,47,0.18), rgba(255,255,255,0.08));
}

.emptyState{
  color: rgba(255,255,255,0.70);
  font-weight: 850;
  text-align:center;
  padding: 18px 10px;
  border: 1px dashed rgba(255,255,255,0.14);
  border-radius: 14px;
  background: rgba(0,0,0,0.12);
}

@media (max-width: 520px){
  header{ grid-template-columns: 1fr; }
  .logoutWrap{ justify-content:center; }
  .stationTitle{ font-size:1.55rem; }
}
</style>
</head>

<body>

<header>
  <div></div>

  <div class="header-center">
    <div class="stationTitle" id="stationTitle">Loading…</div>

    <div class="legend">
      <div class="legendItem"><div class="swatch wip"></div> Work in Progress</div>
      <div class="legendItem"><div class="swatch available"></div> Available</div>
      <div class="legendItem"><div class="swatch na"></div> Not Available</div>
    </div>
  </div>

  <div class="logoutWrap">
    <button id="logoutBtn" class="logoutBtn" type="button">Log out</button>
  </div>
</header>

<div class="page">

  <div class="section wipSection">
    <div class="sectionHead">Work In Progress</div>
    <div class="sectionBody" id="wipBody">
  Loading…
</div>
  </div>

  <div class="section availableSection">
    <div class="sectionHead">Available</div>
    <div class="sectionBody" id="availableBody">
  Loading…
</div>
  </div>

  <div class="section naSection">
    <div class="sectionHead">Not Available</div>
    <div class="sectionBody" id="naBody">
  Loading…
</div>
  </div>

</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
  getFirestore, doc, getDoc, collection, onSnapshot,
  runTransaction, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyD-ArzjlwKTZVpsH4ERg7n-MEgzCt6Nzno",
    authDomain: "prodalign-ltd.firebaseapp.com",
    projectId: "prodalign-ltd"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const logoutBtn = document.getElementById("logoutBtn");
  const stationTitleEl = document.getElementById("stationTitle");
  const wipBody = document.getElementById("wipBody");
const availableBody = document.getElementById("availableBody");
const naBody = document.getElementById("naBody");

function getUserIdentifier(){
  const u = auth.currentUser;
  return u?.email || u?.displayName || u?.uid || "unknown";
}

function opsToString(ops, currentIndex){
  if (!Array.isArray(ops) || ops.length === 0) return "Ops: —";
  return ops
    .map((o, i) => {
      const code = String(o?.code || "").toUpperCase();
      if (!code) return "";
      return (i === currentIndex) ? `[${code}]` : code;
    })
    .filter(Boolean)
    .join(" → ");
}

function renderEmpty(el, text){
  el.innerHTML = `<div class="emptyState">${text}</div>`;
}

function normalizeOpsArray(ops){
  if (!Array.isArray(ops)) return [];
  return ops
    .map(x => {
      const code = String(x?.code || "").trim().toUpperCase();
      const iph = Number(x?.iph);
      return code ? { code, iph: Number.isFinite(iph) ? iph : 0 } : null;
    })
    .filter(Boolean);
}

  // URL params
  const params = new URLSearchParams(window.location.search);
  const companyId = (params.get("c") || "").trim().toLowerCase();
  const stationParam = (params.get("station") || "").trim().toLowerCase();

  // If missing company, bounce
  if (!companyId) {
    window.location.assign("/companylogin/");
    throw new Error("Missing ?c=");
  }

  function prettyStationName(s) {
    return String(s || "")
      .trim()
      .toLowerCase()
      .replace(/[_-]+/g, " ")
      .split(" ")
      .filter(Boolean)
      .map(w => w.charAt(0).toUpperCase() + w.slice(1))
      .join(" ");
  }

  async function hardKickToLogin() {
    try { await signOut(auth); } catch {}
    window.location.assign("/companylogin/");
  }

  async function enforceOperatorGate(user) {
    const snap = await getDoc(doc(db, "users", user.uid));
    if (!snap.exists()) throw new Error("User profile missing.");

    const data = snap.data();

    const userCompany = String(data.companycode ?? data.companyCode ?? "").trim().toLowerCase();
    const role = String(data.role ?? "").trim().toLowerCase();
    const station = String(data.station ?? "").trim().toLowerCase();

    if (!userCompany || userCompany !== companyId) throw new Error("Wrong company.");
    if (role !== "operator") throw new Error("Not an operator.");
    if (!station) throw new Error("Operator missing station.");

    // ✅ Title ALWAYS from Firestore
    stationTitleEl.textContent = `${prettyStationName(station)} Dashboard`;

    // ✅ Force the URL station to the operator's station (or add it)
    if (!stationParam || stationParam !== station) {
      const newUrl = `/company/FloorDashboard.html?c=${encodeURIComponent(companyId)}&station=${encodeURIComponent(station)}`;
      window.location.replace(newUrl);
      return false;
    }

    return { station };
  }

  function watchJobsForStation(stationLower){
  const stationCode = String(stationLower || "").trim().toUpperCase();
  if (!stationCode) return;

  const jobsRef = collection(db, "companies", companyId, "jobs");

  // Listen to ALL jobs for company, then bucket them for THIS station.
  // This avoids complex queries/indexes for now.
  return onSnapshot(jobsRef, (snap) => {
    const available = [];
    const wip = [];
    const notAvailable = [];

    snap.forEach((d) => {
      const job = d.data() || {};
      const id = d.id;

      if (String(job.status || "").toLowerCase() === "complete") return;

      const ops = normalizeOpsArray(job.ops);
      const currentOpIndex = Number(job.currentOpIndex ?? 0);

      // Find where THIS station appears in the ops list
      const myIndex = ops.findIndex(o => o.code === stationCode);
      if (myIndex === -1) return; // job doesn't involve this station

      // If job already passed this station, ignore
      if (currentOpIndex > myIndex) return;

      const currentOpCode = String(job.currentOpCode || "").trim().toUpperCase();
      const status = String(job.status || "").trim().toLowerCase();

      const jobView = {
        id,
        itemCode: String(job.itemCode || "").toUpperCase(),
        orderNo: String(job.orderNo || ""),
        qty: Number(job.qty || 0),
        ops,
        currentOpIndex,
        currentOpCode,
        status,
        assignedTo: String(job.assignedTo || ""),
      };

      // Bucket rules:
      // - If it's our turn (currentOpIndex === myIndex)
      //    - ready => Available
      //    - in_progress => WIP (even if assigned to someone else, we can show "locked")
      // - If we're later in the list (currentOpIndex < myIndex) => Not Available
      if (currentOpIndex === myIndex) {
        if (status === "ready") available.push(jobView);
        else wip.push(jobView);
      } else {
        notAvailable.push(jobView);
      }
    });

    // Render
    renderJobLists({ stationCode, available, wip, notAvailable });
  }, (err) => {
    console.error("Jobs listener error:", err);
    renderEmpty(availableBody, `Error loading jobs: ${err.message}`);
    renderEmpty(wipBody, `Error loading jobs: ${err.message}`);
    renderEmpty(naBody, `Error loading jobs: ${err.message}`);
  });
}
  function renderJobLists({ stationCode, available, wip, notAvailable }){
  // AVAILABLE
  if (!available.length) renderEmpty(availableBody, "No jobs ready for this station.");
  else {
    availableBody.innerHTML = `<div class="jobsGrid">${
      available.map(j => jobCardHtml(j, stationCode, "available")).join("")
    }</div>`;
    wireCardButtons(availableBody, stationCode);
  }

  // WIP
  if (!wip.length) renderEmpty(wipBody, "No jobs in progress at this station.");
  else {
    wipBody.innerHTML = `<div class="jobsGrid">${
      wip.map(j => jobCardHtml(j, stationCode, "wip")).join("")
    }</div>`;
    wireCardButtons(wipBody, stationCode);
  }

  // NOT AVAILABLE
  if (!notAvailable.length) renderEmpty(naBody, "Nothing waiting on previous operations.");
  else {
    naBody.innerHTML = `<div class="jobsGrid">${
      notAvailable.map(j => jobCardHtml(j, stationCode, "na")).join("")
    }</div>`;
    // no buttons here
  }
}

function jobCardHtml(job, stationCode, bucket){
  const title = `${job.itemCode || "—"} × ${job.qty || 0}`;
  const meta = `
    <div class="jobMeta">
      <div><b>Order:</b> ${escapeHtml(job.orderNo || "—")}</div>
      <div><b>Current:</b> ${escapeHtml(String(job.currentOpCode || "—"))}</div>
      <div><b>Status:</b> ${escapeHtml(job.status)}</div>
      ${job.assignedTo ? `<div><b>Assigned:</b> ${escapeHtml(job.assignedTo)}</div>` : ``}
    </div>
  `;

  const opsLine = `<div class="jobOps"><b>Flow:</b> ${escapeHtml(opsToString(job.ops, job.currentOpIndex))}</div>`;

  let btns = "";
  if (bucket === "available") {
    btns = `
      <div class="jobBtns">
        <button class="smallBtn primary" data-start="${job.id}">Start</button>
      </div>
    `;
  } else if (bucket === "wip") {
    // allow Complete. If you want to restrict to only the assigned user, we can enforce it.
    btns = `
      <div class="jobBtns">
        <button class="smallBtn warn" data-complete="${job.id}">Complete / Move On</button>
      </div>
    `;
  }

  return `
    <div class="jobCard">
      <div class="jobTop">
        <div>
          <div class="jobTitle">${escapeHtml(title)}</div>
          ${meta}
        </div>
      </div>
      ${opsLine}
      ${btns}
    </div>
  `;
}

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

function wireCardButtons(container, stationCode){
  container.querySelectorAll("button[data-start]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const id = btn.getAttribute("data-start");
      btn.disabled = true;
      try{
        await startJob(id, stationCode);
      } catch(e){
        console.error(e);
        alert(e?.message || "Could not start job.");
        btn.disabled = false;
      }
    });
  });

  container.querySelectorAll("button[data-complete]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const id = btn.getAttribute("data-complete");
      btn.disabled = true;
      try{
        await completeJobStep(id, stationCode);
      } catch(e){
        console.error(e);
        alert(e?.message || "Could not complete job.");
        btn.disabled = false;
      }
    });
  });
}
  async function startJob(jobId, stationCode){
  const jobRef = doc(db, "companies", companyId, "jobs", jobId);

  await runTransaction(db, async (tx) => {
    const snap = await tx.get(jobRef);
    if (!snap.exists()) throw new Error("Job not found.");

    const job = snap.data() || {};
    const status = String(job.status || "").toLowerCase();
    const currentOpCode = String(job.currentOpCode || "").toUpperCase();

    if (status !== "ready") throw new Error("This job is not available.");
    if (currentOpCode !== stationCode) throw new Error("This job is not for your station.");

    tx.update(jobRef, {
      status: "in_progress",
      assignedTo: getUserIdentifier(),
      startedAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
  });
}

async function completeJobStep(jobId, stationCode){
  const jobRef = doc(db, "companies", companyId, "jobs", jobId);

  await runTransaction(db, async (tx) => {
    const snap = await tx.get(jobRef);
    if (!snap.exists()) throw new Error("Job not found.");

    const job = snap.data() || {};
    const ops = normalizeOpsArray(job.ops);
    const idx = Number(job.currentOpIndex ?? 0);
    const currentOpCode = String(job.currentOpCode || "").toUpperCase();
    const status = String(job.status || "").toLowerCase();

    if (!ops.length) throw new Error("Job has no operations.");
    if (currentOpCode !== stationCode) throw new Error("This job is not at your station.");

    // Optional: only allow complete if it's in_progress
    // if (status !== "in_progress") throw new Error("Start the job before completing.");

    const nextIndex = idx + 1;

    if (nextIndex < ops.length) {
      tx.update(jobRef, {
        currentOpIndex: nextIndex,
        currentOpCode: ops[nextIndex].code,
        status: "ready",
        assignedTo: null,
        updatedAt: serverTimestamp()
      });
    } else {
      tx.update(jobRef, {
        status: "complete",
        assignedTo: null,
        completedAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
    }
  });
}
  // ✅ Auth gate
  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      window.location.assign("/companylogin/");
      return;
    }

    try {
      const result = await enforceOperatorGate(user);
if (!result) return;

const { station } = result;

// ✅ start live job feed for this operator station
watchJobsForStation(station);
      // ✅ at this point: user is operator + correct company + correct station dashboard
      // later: load jobs for this station using station from Firestore (NOT the URL)

    } catch (e) {
      console.error(e);
      await hardKickToLogin();
    }
  });

  // ✅ Logout button
  logoutBtn.addEventListener("click", async () => {
    await hardKickToLogin();
  });
</script>

</body>
</html>
